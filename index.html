<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>VP Wordle</title>

  <style>
    :root{
      --bg:#0f1115;
      --tile:#1a1d24;
      --tile-border:#2a2f3a;
      --text:#e7e9ee;
      --muted:#8b90a0;
      --green:#2fbf71;
      --yellow:#f2c94c;
      --grey:#3a3f4b;
      --key:#232734;
      --key-text:#e7e9ee;
      --key-disabled:#151824;
      --panel:#161922;
      --panel-border:#262a36;
    }
    *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
    body{
      margin:0; background:var(--bg); color:var(--text);
      display:flex; flex-direction:column; align-items:center;
      min-height:100vh; padding:18px 12px 28px; gap:12px;
    }
    h1{ margin:6px 0 0; letter-spacing:2px; font-weight:800; }
    .sub{ color:var(--muted); font-size:14px; margin-top:-6px; text-align:center; }

    .board{
      display:grid; grid-template-rows: repeat(6, 1fr);
      gap:8px; margin-top:8px; width:min(92vw, 380px);
    }
    .row{ display:grid; grid-template-columns: repeat(5, 1fr); gap:8px; }
    .tile{
      aspect-ratio:1/1; background:var(--tile);
      border:2px solid var(--tile-border); border-radius:10px;
      display:flex; align-items:center; justify-content:center;
      font-size:28px; font-weight:800; text-transform:uppercase;
      transition:transform .08s ease, background .2s ease, border-color .2s ease;
      user-select:none;
    }
    .tile.pop{ transform:scale(1.05); }
    .tile.green{ background:var(--green); border-color:var(--green); color:#0b0d12; }
    .tile.yellow{ background:var(--yellow); border-color:var(--yellow); color:#0b0d12; }
    .tile.grey{ background:var(--grey); border-color:var(--grey); color:#e5e7eb; }

    .status{ min-height:22px; font-size:15px; color:var(--muted); text-align:center; margin-top:2px; }

    .keyboard{
      display:flex; flex-direction:column; gap:8px;
      width:min(96vw, 520px); margin-top:6px;
    }
    .keyrow{ display:flex; gap:6px; justify-content:center; }
    button.key{
      background:var(--key); color:var(--key-text); border:none;
      padding:12px 10px; border-radius:10px; font-weight:700;
      font-size:14px; min-width:34px; cursor:pointer;
      transition:filter .12s ease, transform .05s ease, background .2s ease;
      text-transform:uppercase; user-select:none;
    }
    button.key:active{ transform:translateY(1px); }
    button.key.wide{ min-width:64px; }
    button.key.green{ background:var(--green); color:#0b0d12; }
    button.key.yellow{ background:var(--yellow); color:#0b0d12; }
    button.key.grey{ background:var(--grey); color:#e5e7eb; }
    button.key.disabled{ background:var(--key-disabled); color:#555b6d; cursor:not-allowed; }

    .footer{ color:var(--muted); font-size:12px; margin-top:auto; opacity:.9; }

    /* Auth panel */
    .auth-panel{
      width:min(92vw, 520px);
      background:var(--panel);
      border:1px solid var(--panel-border);
      border-radius:12px;
      padding:10px;
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:center;
      margin-top:2px;
    }
    .auth-panel input{
      flex:1;
      min-width:140px;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid #333845;
      background:#0f1115;
      color:var(--text);
      outline:none;
    }
    .auth-panel button{
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:700;
      border:1px solid #333845;
      background:#1f2430;
      color:var(--text);
    }
    .auth-panel button:hover{ filter:brightness(1.08); }
    .auth-note{ font-size:12px; color:var(--muted); text-align:center; margin-top:-4px; }

    /* Cool login button states */
    .auth-btn{
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap:8px;
      min-width:150px;
      transition: transform .08s ease, filter .2s ease, opacity .2s ease;
    }
    .auth-btn:hover{ filter:brightness(1.12); }
    .auth-btn:active{ transform: translateY(1px) scale(0.98); }
    .auth-btn.loading{
      opacity:0.85;
      cursor: wait;
      transform: scale(0.98);
    }
    .auth-btn .btn-text{ transition: opacity .15s ease; }
    .auth-btn.loading .btn-text{ opacity:0.75; }
    .spinner{
      width:16px; height:16px; border-radius:50%;
      border:2px solid rgba(255,255,255,0.25);
      border-top-color: rgba(255,255,255,0.9);
      display:none; animation: spin .8s linear infinite;
    }
    .auth-btn.loading .spinner{ display:inline-block; }
    @keyframes spin{ to { transform: rotate(360deg); } }
    .auth-btn.success{ animation: pulse .6s ease; }
    @keyframes pulse{
      0%{ transform:scale(1); }
      50%{ transform:scale(1.06); }
      100%{ transform:scale(1); }
    }

    /* ===== VP LOADER ===== */
    .vp-loader{
      position:fixed; inset:0;
      background: radial-gradient(ellipse at center, #141824 0%, #0b0d12 60%, #05060a 100%);
      display:flex; align-items:center; justify-content:center;
      z-index:9999; opacity:1; transition: opacity 700ms ease;
    }
    .vp-loader.hide{ opacity:0; pointer-events:none; }
    .vp-loader-inner{
      display:flex; flex-direction:column; align-items:center; gap:12px;
      transform: translateY(-10px);
    }
    .vp-loader-img{
      width:140px; height:140px; border-radius:50%; object-fit:cover;
      border:3px solid rgba(255,255,255,0.08);
      box-shadow: 0 0 40px rgba(47,191,113,0.18);
      animation: vpSpin 2.8s linear infinite, vpFloat 1.6s ease-in-out infinite;
    }
    .vp-loader-title{
      font-size:32px; font-weight:900; letter-spacing:3px; text-transform:uppercase;
      background: linear-gradient(90deg, #ffffff, #9ad7ff, #ffffff);
      -webkit-background-clip:text; background-clip:text; color:transparent;
      animation: vpGlow 1.8s ease-in-out infinite;
    }
    .vp-loader-sub{
      font-size:14px; color:#9aa1b2; letter-spacing:1px; text-transform:uppercase;
    }
    .dots span{ display:inline-block; animation: dotBounce 1.1s infinite; }
    .dots span:nth-child(2){ animation-delay: .15s; }
    .dots span:nth-child(3){ animation-delay: .30s; }

    @keyframes vpSpin{ to{ transform: rotate(360deg); } }
    @keyframes vpFloat{ 0%,100%{ transform: translateY(0); } 50%{ transform: translateY(-6px); } }
    @keyframes vpGlow{ 0%,100%{ filter:none; } 50%{ filter: drop-shadow(0 0 12px rgba(154,215,255,0.55)); } }
    @keyframes dotBounce{ 0%,100%{ transform: translateY(0); opacity:.4; } 50%{ transform: translateY(-4px); opacity:1; } }

    .game-wrapper{
      opacity:0; transition: opacity 600ms ease; width:100%;
      display:flex; flex-direction:column; align-items:center; gap:12px;
    }
    .game-wrapper.show{ opacity:1; }
  </style>
</head>
<body>

  <!-- VP Wordle Loading Screen -->
  <div id="vpLoader" class="vp-loader">
    <div class="vp-loader-inner">
      <img
        src="https://github.com/chrisvp5/VPwordle/blob/main/Copy%20of%20Jay%20Recycle%20.png?raw=true"
        alt="VP Loader"
        class="vp-loader-img"
      />
      <div class="vp-loader-title">VP WORDLE</div>
      <div class="vp-loader-sub">
        Loading <span class="dots"><span>.</span><span>.</span><span>.</span></span>
      </div>
    </div>
  </div>

  <div id="gameWrapper" class="game-wrapper">
    <h1>WORDLE</h1>
    <div class="sub">Guess the 5 letter word. You have 6 tries.</div>

    <div id="board" class="board"></div>
    <div id="status" class="status"></div>

    <div class="auth-panel" id="authBox">
      <input id="emailInput" type="email" placeholder="Enter email to login" />
      <button id="loginBtn" class="auth-btn">
        <span class="btn-text">Send login link</span>
        <span class="spinner" aria-hidden="true"></span>
      </button>
      <button id="logoutBtn" style="display:none;">Logout</button>
    </div>
    <div class="auth-note">Login is optional. If you login, your result is saved.</div>

    <div id="keyboard" class="keyboard"></div>
    <div class="footer">Physical keyboard supported.</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <script>
  (() => {
    "use strict";

    function setStatus(msg, solid=false) {
      const statusEl = document.getElementById("status");
      if (!statusEl) return;
      statusEl.textContent = msg;
      statusEl.style.color = solid ? "var(--text)" : "var(--muted)";
    }

    window.addEventListener("error", (e) => {
      setStatus("JS error: " + e.message, true);
      console.error(e);
    });
    window.addEventListener("unhandledrejection", (e) => {
      const msg = e.reason?.message || String(e.reason);
      setStatus("Async error: " + msg, true);
      console.error(e);
    });

    const vpLoader = document.getElementById("vpLoader");
    const gameWrapper = document.getElementById("gameWrapper");
    function hideLoader() {
      if (!vpLoader) return;
      vpLoader.classList.add("hide");
      gameWrapper.classList.add("show");
      setTimeout(() => vpLoader.remove(), 800);
    }
    const returningFromLogin =
      window.location.hash.includes("access_token") ||
      window.location.search.includes("code=");
    setTimeout(hideLoader, returningFromLogin ? 300 : 5500);

    // ==================== SUPABASE ====================
    const SUPABASE_URL = "https://ruenrertnvhyglbwhqpc.supabase.co";
    const SUPABASE_ANON_KEY = "sb_publishable_3jLPUT8TNCr-gJtrA5rPFg_A11cxx2G";

    let supabase = null;

    const emailInput = document.getElementById("emailInput");
    const loginBtn = document.getElementById("loginBtn");
    const logoutBtn = document.getElementById("logoutBtn");
    const authBox = document.getElementById("authBox");

    try {
      if (window.supabase) {
        supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
          auth: {
            persistSession: true,
            detectSessionInUrl: true   // ✅ THIS is the key fix
          }
        });
        // ✅ Force-consume magic link tokens from URL hash (GitHub Pages safe)
async function consumeHashSessionIfPresent() {
  if (!supabase) return false;

  const rawHash = window.location.hash || "";
  if (!rawHash.includes("access_token") || !rawHash.includes("refresh_token")) {
    return false;
  }

  const hash = rawHash.replace(/^#/, "");
  const params = new URLSearchParams(hash);

  const access_token = params.get("access_token");
  const refresh_token = params.get("refresh_token");

  if (!access_token || !refresh_token) return false;

  const { data, error } = await supabase.auth.setSession({
    access_token,
    refresh_token
  });

  if (error) {
    console.error("setSession failed:", error);
    setStatus("Login failed. Please try again.", true);
    return false;
  }

  if (data?.session?.user) {
    setStatus("Logged in successfully.", true);

    // clean URL
    history.replaceState({}, document.title, window.location.pathname);
    return true;
  }

  return false;
}
      // ✅ Wait for Supabase to process magic link URL, then refresh UI
async function consumeMagicLinkSessionIfPresent() {
  if (!supabase) return;

  const hasCode = window.location.search.includes("code=");
  const hasHashTokens =
    window.location.hash.includes("access_token") ||
    window.location.hash.includes("refresh_token");

  if (!hasCode && !hasHashTokens) return;

  // Give Supabase a moment to auto-detect from URL
  await new Promise(r => setTimeout(r, 300));

  // If auto-detect didn't work and we have a code, try exchange manually
  if (hasCode && supabase.auth.exchangeCodeForSession) {
    const urlParams = new URLSearchParams(window.location.search);
    const code = urlParams.get("code");
    if (code) {
      const { data, error } = await supabase.auth.exchangeCodeForSession(code);
      if (error) {
        console.error("exchangeCodeForSession failed:", error);
        setStatus("Login failed. Try again.", true);
        return;
      }
      if (data?.session) {
        setStatus("Logged in successfully.", true);
      }
    }
  }

  // Now check session
  const { data: { session } } = await supabase.auth.getSession();

  if (session?.user) {
    await refreshAuthUI();

    // ✅ ONLY clean URL after session is confirmed
    history.replaceState({}, document.title, window.location.pathname);
  } else {
    // show a useful message instead of silent fail
    setStatus("Login link opened, but no session was created. Check redirect URLs.", true);
  }
}
      } else {
        authBox.style.display = "none";
      }
    } catch (e) {
      authBox.style.display = "none";
      console.error(e);
    }

    async function refreshAuthUI() {
      if (!supabase) return;
      const { data: { user } } = await supabase.auth.getUser();
      if (user) {
        loginBtn.style.display = "none";
        emailInput.style.display = "none";
        logoutBtn.style.display = "inline-block";
        setStatus("Logged in as " + user.email);
      } else {
        loginBtn.style.display = "inline-flex";
        emailInput.style.display = "inline-block";
        logoutBtn.style.display = "none";
      }
    }

    loginBtn.onclick = async () => {
      if (!supabase) return setStatus("Login not configured yet.");

      const email = emailInput.value.trim();
      if (!email) return setStatus("Enter an email to login.");

      loginBtn.classList.add("loading");
      loginBtn.disabled = true;
      setStatus("Sending magic link...");

      try {
        const { error } = await supabase.auth.signInWithOtp({
          email,
          options: {
            emailRedirectTo: "https://chrisvp5.github.io/VPwordle/"
          }
        });
        if (error) return setStatus("Login error: " + error.message, true);

        loginBtn.classList.remove("loading");
        loginBtn.classList.add("success");
        setTimeout(() => loginBtn.classList.remove("success"), 700);
        setStatus("Magic link sent. Check your email.");
      } finally {
        loginBtn.classList.remove("loading");
        loginBtn.disabled = false;
      }
    };

    logoutBtn.onclick = async () => {
      if (!supabase) return;
      await supabase.auth.signOut();
      refreshAuthUI();
      setStatus("Logged out.");
    };

    if (supabase) {
      supabase.auth.onAuthStateChange(() => refreshAuthUI());
      refreshAuthUI(); // ✅ show correct state on first load
    }

    async function saveResultToSupabase({ puzzleId, guessesUsed, won }) {
      if (!supabase) return;
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;
      await supabase.from("vpwordle_results").upsert({
        user_id: user.id,
        puzzle_id: puzzleId,
        guesses_used: guessesUsed,
        won
      });
    }

    // ==================== WORDLE GAME ====================
    let solutions = [];
    let validGuesses = new Set();
    let _answer = "";
    const setAnswer = (w) => { _answer = w; };

    const boardEl = document.getElementById("board");
    const keyboardEl = document.getElementById("keyboard");

    let currentRow = 0;
    let currentCol = 0;
    let isGameOver = false;
    const guesses = Array.from({ length: 6 }, () => Array(5).fill(""));
    const keyState = {};

    async function loadWordLists() {
  try {
    const base = window.location.href;  // ✅ always correct on GH Pages

    const solURL = new URL("solutions.txt", base);
    const guessURL = new URL("guesses.txt", base);

    // cache busting
    solURL.searchParams.set("v", Date.now());
    guessURL.searchParams.set("v", Date.now());

    const [solRes, guessRes] = await Promise.all([
      fetch(solURL, { cache: "no-store" }),
      fetch(guessURL, { cache: "no-store" }),
    ]);

    if (!solRes.ok) throw new Error("solutions.txt HTTP " + solRes.status);
    if (!guessRes.ok) throw new Error("guesses.txt HTTP " + guessRes.status);

    const solText = await solRes.text();
    const guessText = await guessRes.text();

    solutions = solText
      .split(/\r?\n/)
      .map(w => w.trim().toLowerCase())
      .filter(w => w.length === 5);

    const guessesArr = guessText
      .split(/\r?\n/)
      .map(w => w.trim().toLowerCase())
      .filter(w => w.length === 5);

    validGuesses = new Set([...solutions, ...guessesArr]);

    if (!solutions.length) throw new Error("solutions list empty");
    if (!validGuesses.size) throw new Error("guess list empty");
  } catch (err) {
    console.error("Word list load failed:", err);

    // ✅ fallback so game still loads
    solutions = ["crane","plane","stare","trace","slate","charm","flint","pride","sugar","storm"];
    validGuesses = new Set(solutions);

    setStatus(
      "Could not load word lists from GitHub Pages, using fallback list.",
      true
    );
  }
}


    function getDailyIndex() {
      const start = new Date("2021-06-19T00:00:00Z");
      const now = new Date();
      const utcToday = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
      return Math.floor((utcToday - start) / (1000*60*60*24));
    }
    const getPuzzleId = () => getDailyIndex();

    function pickAnswer() {
      const idx = getDailyIndex() % solutions.length;
      setAnswer(solutions[idx]);
    }

    function saveState() {
      localStorage.setItem("vpwordle_state", JSON.stringify({
        puzzleId:getPuzzleId(), guesses, currentRow, currentCol, isGameOver, keyState
      }));
    }

    function loadState() {
      const raw = localStorage.getItem("vpwordle_state");
      if (!raw) return false;
      try {
        const state = JSON.parse(raw);
        if (state.puzzleId !== getPuzzleId()) {
          localStorage.removeItem("vpwordle_state");
          return false;
        }
        for (let r=0;r<6;r++) for (let c=0;c<5;c++) guesses[r][c] = state.guesses?.[r]?.[c] || "";
        currentRow = state.currentRow || 0;
        currentCol = state.currentCol || 0;
        isGameOver = !!state.isGameOver;
        Object.assign(keyState, state.keyState || {});
        return true;
      } catch { return false; }
    }

    function buildBoard() {
      boardEl.innerHTML = "";
      for (let r=0;r<6;r++) {
        const row = document.createElement("div");
        row.className = "row";
        for (let c=0;c<5;c++) {
          const tile = document.createElement("div");
          tile.className = "tile";
          tile.id = `tile-${r}-${c}`;
          row.appendChild(tile);
        }
        boardEl.appendChild(row);
      }
    }

    const KEY_LAYOUT = [
      ["q","w","e","r","t","y","u","i","o","p"],
      ["a","s","d","f","g","h","j","k","l"],
      ["enter","z","x","c","v","b","n","m","backspace"]
    ];

    function buildKeyboard() {
      keyboardEl.innerHTML = "";
      KEY_LAYOUT.forEach(rowKeys => {
        const row = document.createElement("div");
        row.className = "keyrow";
        rowKeys.forEach(k => {
          const btn = document.createElement("button");
          btn.className = "key";
          btn.dataset.key = k;
          btn.textContent = (k === "backspace") ? "⌫" : k;
          if (k === "enter" || k === "backspace") btn.classList.add("wide");
          btn.onclick = () => handleKey(k);
          row.appendChild(btn);
        });
        keyboardEl.appendChild(row);
      });
    }

    function updateTile(r,c,letter){
      const tile = document.getElementById(`tile-${r}-${c}`);
      tile.textContent = letter;
      if (letter) {
        tile.classList.add("pop");
        setTimeout(()=>tile.classList.remove("pop"),90);
      }
    }

    function paintRow(r,colours){
      for (let c=0;c<5;c++) {
        document.getElementById(`tile-${r}-${c}`).classList.add(colours[c]);
      }
    }

    function upgradeKeyState(letter,newState){
      const rank={unknown:0,grey:1,yellow:2,green:3};
      const old=keyState[letter]||"unknown";
      if(rank[newState]>rank[old]) keyState[letter]=newState;
    }

    function repaintKeyboard(){
      document.querySelectorAll("button.key").forEach(btn=>{
        const k=btn.dataset.key;
        btn.classList.remove("green","yellow","grey","disabled");
        if(k.length===1){
          const st=keyState[k]||"unknown";
          if(st!=="unknown") btn.classList.add(st);
          if(st==="grey") btn.classList.add("disabled");
        }
      });
    }

    function scoreGuess(guess){
      const answer=_answer;
      const result=Array(5).fill("grey");
      const a=answer.split("");
      const g=guess.split("");

      for(let i=0;i<5;i++){
        if(g[i]===a[i]){
          result[i]="green";
          a[i]=null; g[i]=null;
        }
      }
      for(let i=0;i<5;i++){
        if(g[i] && a.includes(g[i])){
          result[i]="yellow";
          a[a.indexOf(g[i])]=null;
        }
      }
      return result;
    }

    function handleKey(key){
      if(isGameOver) return;

      if(key==="enter"){
        const guess=guesses[currentRow].join("");
        if(guess.length<5) return setStatus("Not enough letters.");
        if(!validGuesses.has(guess)) return setStatus("Not in word list.");

        const colours=scoreGuess(guess);
        paintRow(currentRow,colours);

        for(let i=0;i<5;i++) upgradeKeyState(guess[i],colours[i]);
        repaintKeyboard();
        saveState();

        if(guess===_answer){
          isGameOver=true; saveState();
          saveResultToSupabase({ puzzleId:getPuzzleId(), guessesUsed:currentRow+1, won:true });
          return setStatus(`You got it. The word was ${_answer.toUpperCase()}.`,true);
        }

        currentRow++; currentCol=0;

        if(currentRow===6){
          isGameOver=true; saveState();
          saveResultToSupabase({ puzzleId:getPuzzleId(), guessesUsed:6, won:false });
          return setStatus(`Out of guesses. The word was ${_answer.toUpperCase()}.`,true);
        }

        setStatus("");
        return;
      }

      if(key==="backspace"){
        if(currentCol>0){
          currentCol--;
          guesses[currentRow][currentCol]="";
          updateTile(currentRow,currentCol,"");
        }
        return;
      }

      if(/^[a-z]$/.test(key)){
        if(currentCol<5){
          guesses[currentRow][currentCol]=key;
          updateTile(currentRow,currentCol,key);
          currentCol++;
        }
      }
    }

    window.addEventListener("keydown",(e)=>{
      if (typeof e.key !== "string") return;
      const k=e.key.toLowerCase();
      if(k==="enter"||k==="backspace"||/^[a-z]$/.test(k)) handleKey(k);
    });

    async function startGame() {
      try {
        await consumeHashSessionIfPresent();
        setStatus("Loading word lists...");
        await loadWordLists();

    pickAnswer();
    buildBoard();
    buildKeyboard();

  // 3) Restore saved progress if same daily puzzle
  const restored = loadState();

  if (restored) {
    for (let r = 0; r < 6; r++) {
      const guessStr = guesses[r].join("");
      if (!guessStr) continue;

      // paint letters back in
      for (let c = 0; c < 5; c++) {
        updateTile(r, c, guesses[r][c]);
      }

      // paint colours for completed rows
      if (r < currentRow) {
        const colours = scoreGuess(guessStr);
        paintRow(r, colours);
        for (let i = 0; i < 5; i++) {
          upgradeKeyState(guessStr[i], colours[i]);
        }
      }
    }

    repaintKeyboard();

    // if game was already finished, show final message
    if (isGameOver) {
      const lastGuess = guesses[currentRow - 1]?.join("") || "";
      if (lastGuess === _answer) {
        setStatus(`You got it. The word was ${_answer.toUpperCase()}.`, true);
      } else {
        setStatus(`Out of guesses. The word was ${_answer.toUpperCase()}.`, true);
      }
    } else {
      setStatus("");
    }
  } else {
    // fresh puzzle state
    guesses.forEach(r => r.fill(""));
    currentRow = 0;
    currentCol = 0;
    isGameOver = false;
    for (const k in keyState) delete keyState[k];
    saveState();
    setStatus("");
  }

  // 4) Finally, refresh login UI
  refreshAuthUI();
}
async function consumeHashSessionIfPresent() {
  if (!supabase) return;

  const hash = window.location.hash.replace(/^#/, "");
  if (!hash) return;

  const params = new URLSearchParams(hash);
  const access_token = params.get("access_token");
  const refresh_token = params.get("refresh_token");
  const error_description = params.get("error_description");

  if (error_description) {
    setStatus("Login link error: " + decodeURIComponent(error_description), true);
    console.error("Magic link error:", error_description);
    return;
  }

  if (access_token && refresh_token) {
    console.log("Consuming magic link tokens…");

    const { error } = await supabase.auth.setSession({
      access_token,
      refresh_token,
    });

    if (error) {
      console.error("setSession failed:", error);
      setStatus("Login failed. Try again.", true);
      return;
    }

    console.log("Magic link login successful!");

    // remove hash from URL
    history.replaceState({}, document.title, window.location.pathname);

    setStatus("Logged in successfully!", true);
  }
}


    startGame();
  })();
  </script>
</body>
</html>




